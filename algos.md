| **Category & Pattern**                                 | **When to Use**                                                                                                                                                                                          | **Technique & Examples**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|--------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Arrays & Strings: Sliding Window**                   | - For longest/shortest contiguous **`subarray`**/**`substring`** problems. <br> - **Keywords:** "**`subarray`**", "**`substring`**", "**`continuous`**", "**`maximize`**", "**`minimize`**".               | - Maintain a dynamic window with two pointers (start & end); expand the window until the condition is violated, then contract it to restore validity. Start by iterating with the right pointer and update counts using Python’s `collections.Counter` or a simple dict, then adjust the left pointer based on the tracked state. Use slicing and built-in functions like `max()` to capture optimal results. **Example:** Longest Substring Without Repeating Characters.                                                                                                             |
| **Arrays & Strings: Two Pointers**                     | - For sorted array problems (finding pairs, triplets, or partitions) or when comparing elements from both ends. <br> - **Keywords:** "**`sorted`**", "**`pair`**", "**`triplet`**", "**`partition`**".              | - Initialize two pointers (one at each end or with one fast/slow pointer) and move them based on comparisons until the target condition is met. Begin by checking edge cases (empty input, one-element arrays) and leverage Python’s built-in sorting if needed. Use simple iterative loops and consider functions like `sorted()` and list comprehensions for quick filtering.  - **Example:** Two Sum II (sorted input).                                                                                                                          |
| **Arrays & Strings: Prefix Sum & Hashing**             | - When the problem involves sums of subarrays or counting occurrences. <br> - **Keywords:** "**`subarray sum equals K`**", "**`group anagrams`**", "**`frequency`**".                                              | - Compute a running prefix sum while storing encountered sums in a hash map to quickly identify subarrays meeting the target. Begin by iterating over the array and updating the cumulative sum; use Python dictionaries for constant-time lookups. Utilize built-in functions like `sum()` where applicable, and consider `itertools.accumulate` for cleaner prefix sum calculations.  - **Example:** Subarray Sum Equals K.                                                                                                                             |
| **Graphs & Trees: Breadth-First Search (BFS)**         | - For shortest path problems or level-order traversal. <br> - **Keywords:** "**`minimum moves`**", "**`closest distance`**", "**`level order`**".                                                      | - Use a queue (e.g. Python’s `collections.deque`) to process nodes level by level, ensuring each node is visited once. Start by enqueuing the initial node and iteratively processing its neighbors, marking nodes as visited. This approach guarantees the shallowest solution is found first.  - **Example:** Binary Tree Level Order Traversal.                                                                                                                           |
| **Graphs & Trees: Depth-First Search (DFS)**           | - When exploring all paths or performing complete tree/graph traversals. <br> - **Keywords:** "**`all paths`**", "**`full traversal`**", "**`backtracking`**".                                      | - Use recursion (or an explicit stack) to explore as deep as possible before backtracking. Start by writing a recursive function that processes the current node and then calls itself for each child. In Python, recursion is natural, but use iterative methods (like a list as a stack) if deep recursion might be an issue. Consider using helper functions to encapsulate the recursive logic.  - **Example:** Lowest Common Ancestor.                                                                                       |
| **Graphs & Trees: Union-Find (Disjoint Set)**          | - For problems involving pairwise connections and grouping, such as detecting cycles or counting connected components.  - **Keywords:** "**`connected components`**", "**`cycle detection`**", "**`grouping`**".                   | - Initialize each node as its own set and merge them as connections are processed, applying path compression for efficiency. Start by iterating over each connection and performing union operations; use a simple Python list or dict to maintain parent pointers. This method reduces repeated traversal and quickly identifies connected components.  - **Example:** Number of Islands.                                                                                                                   |
| **Graphs & Trees: Topological Sort**                   | - When ordering tasks with dependencies (prerequisites). <br> - **Keywords:** "**`prerequisites`**", "**`dependency`**", "**`ordering`**", "**`course schedule`**".                                | - Use Kahn's Algorithm by computing in-degrees and processing nodes with zero in-degree using a queue, or apply a DFS-based approach to record finishing times. Start by constructing a graph representation (using dictionaries or lists) and then iteratively remove nodes with no dependencies. In Python, `collections.deque` can be useful for the queue implementation.  - **Example:** Course Schedule.                                                                                             |
| **Backtracking & Recursion: Permutations & Combinations** | - For generating all possible arrangements. <br> - **Keywords:** "**`all permutations`**", "**`subsets`**", "**`combinations`**".                                                                          | - Use recursion to build candidates incrementally, and backtrack by undoing choices when constraints fail. Begin by defining a helper function that adds one element at a time, and prune paths that are invalid. Python’s recursive function calls and list slicing make this approach natural and concise.  - **Example:** Permutations.                                                                                                                                        |
| **Backtracking & Recursion: Constraint Satisfaction / Puzzle Solving** | - When you must find a configuration that meets strict constraints. <br> - **Keywords:** "**`solve`**", "**`arrangement`**", "**`configuration`**", "**`puzzle`**".                      | - Recursively try all options while immediately pruning any branch that violates constraints to reduce the search space. Start by identifying the decision points and use recursion to explore each, then backtrack as soon as an invalid state is reached. In Python, list comprehensions or generator expressions can help filter out invalid choices early.  - **Example:** N-Queens.                                                                                       |
| **Backtracking & Recursion: Divide & Conquer (Recursive)** | - For problems that can be split into similar, independent subproblems. <br> - **Keywords:** "**`divide and conquer`**", "**`recursive`**", "**`merge sort`**", "**`quickselect`**".                          | - Break the problem into smaller subproblems, solve each recursively, and then combine their solutions. Start with clear base cases to stop recursion, and use Python’s slicing to easily divide lists. This approach simplifies complex problems by reducing them to simpler ones.  - **Example:** Merge Sort.                                                                                                                                |
| **Dynamic Programming (DP): 1D Sequence DP**           | - When optimal solutions for a sequence depend on previous decisions. <br> - **Keywords:** "**`maximum`**", "**`minimum`**", "**`count`**", "**`ways`**", "**`optimal substructure`**".            | - Define a one-dimensional DP array where each entry is computed from previous values using a recurrence relation. Begin by identifying the base case(s) and iteratively build the solution while storing intermediate results in a list or dictionary. Python list comprehensions and the `max()` or `min()` functions can be very handy.  - **Example:** Climbing Stairs.                                                                                                                        |
| **Dynamic Programming (DP): 2D DP (Grids/Matrix)**     | - For problems with two varying parameters, such as comparing two sequences or navigating a grid. <br> - **Keywords:** "**`2D`**", "**`matrix`**", "**`grid`**", "**`edit distance`**", "**`LCS`**". | - Build a 2D DP table (a list of lists) where each cell represents a subproblem; fill it iteratively based on defined transitions. Start by initializing boundaries (e.g., first row/column) and then use nested loops to fill the table. Python’s list comprehensions can help create and manage the DP table efficiently.  - **Example:** Edit Distance.                                                                                                   |
| **Dynamic Programming (DP): State-Space DP (Bitmask, Tree DP)** | - For advanced problems with multiple state variables or combinatorial choices. <br> - **Keywords:** "**`choose subset`**", "**`bitmask`**", "**`state DP`**", "**`tree DP`**".                   | - Represent each state (often with a bitmask) and use recursion with memoization (via a dictionary or `functools.lru_cache`) to avoid recomputation. Start by clearly defining the state and then build a recursive solution that caches intermediate results. This method is powerful for reducing exponential time to manageable levels.  - **Example:** Traveling Salesman Problem.                                                                                                                       |
| **Linked Lists: Fast & Slow Pointers**                 | - For detecting cycles or finding the middle element of a list. <br> - **Keywords:** "**`cycle`**", "**`loop detection`**", "**`middle element`**", "**`Floyd's`**".                           | - Use two pointers moving at different speeds; if the fast pointer catches up to the slow one, a cycle exists, or the slow pointer indicates the midpoint. Begin by initializing both pointers at the head and increment them accordingly. In Python, a simple while loop is sufficient, and careful null checks are essential to avoid errors.  - **Example:** Cycle Detection using Floyd’s Algorithm.                                                                                        |
| **Linked Lists: In-Place Reversal / Reordering**       | - For reversing a list (entirely or in groups) or rearranging nodes. <br> - **Keywords:** "**`reverse`**", "**`swap nodes`**", "**`reverse in groups`**".                                     | - Iterate through the list and reverse the pointers as you go, optionally using a dummy node to simplify edge cases. Start by initializing previous and current pointers and update them iteratively. Python’s tuple unpacking can help swap pointers cleanly.  - **Example:** Reverse Linked List.                                                                                                                             |
| **Linked Lists: Merging / Copying Lists**              | - For merging sorted lists or duplicating lists with extra pointers. <br> - **Keywords:** "**`merge`**", "**`copy`**", "**`duplicate`**", "**`random pointer`**".                       | - Merge lists using a two-pointer approach, or copy nodes by interleaving the copy with the original list and then separating them. Start by comparing nodes from each list and building a new list, possibly using a dummy head for simplicity. Python’s list manipulation and iteration make this straightforward.  - **Example:** Merge Two Sorted Lists.                                                                                                      |
| **Searching, Sorting & Heaps: Binary Search**          | - For problems on sorted arrays or defined search spaces. <br> - **Keywords:** "**`find`**", "**`first occurrence`**", "**`boundary`**", "**`optimal value`**", "**`sorted`**".         | - Use binary search to repeatedly halve the search space by comparing the middle element with the target condition. Start with low and high indices and adjust based on comparisons; consider edge cases to avoid infinite loops. Python’s `bisect` module can be used for standard binary search operations.  - **Example:** Search in Rotated Sorted Array.                                                                                                                |
| **Searching, Sorting & Heaps: Sorting & Intervals**    | - For problems with intervals or overlapping ranges needing ordering. <br> - **Keywords:** "**`intervals`**", "**`overlap`**", "**`merge`**", "**`sorted`**".                           | - First sort the intervals by a key (typically the start time) and then iterate to merge overlapping intervals using a greedy strategy. Start by comparing the current interval with the next to decide if they merge. Python’s `sorted()` function is key here, along with list comprehensions for processing.  - **Example:** Merge Intervals.                                                                                                                                    |
| **Searching, Sorting & Heaps: Heaps / Priority Queues**| - For retrieving extreme elements (e.g., k-th largest) or processing streaming data efficiently. <br> - **Keywords:** "**`heap`**", "**`priority queue`**", "**`top k`**", "**`streaming`**".  | - Use a min-heap or max-heap (via Python’s `heapq` module) to maintain and retrieve the extreme elements. Start by pushing elements onto the heap and, for top-k problems, maintain the heap at a fixed size. This approach allows for efficient extraction of required elements without full sorting.  - **Example:** Kth Largest Element in an Array.                                                                                                                      |
| **Miscellaneous: Bit Manipulation**                    | - For low-level operations on bits or when minimal extra space is required. <br> - **Keywords:** "**`bitwise`**","**`XOR`**","**`shift`**","**`power of 2`**".                             | - Apply bitwise operators (AND, OR, XOR, shifts) to manipulate numbers; use XOR to cancel duplicate pairs. Begin by considering bit-level properties and use Python’s bitwise operators (`&`, `|`, `^`, `<<`, `>>`) for efficient computation. This approach is often optimal for problems with strict space constraints.  - **Example:** Single Number.                                                                                           |
| **Miscellaneous: Mathematical Puzzles**                | - For problems with strong numerical or combinatorial components. <br> - **Keywords:** "**`modulo`**", "**`fibonacci`**", "**`prime`**", "**`factorial`**", "**`formula`**".            | - Leverage known mathematical formulas or iterative methods to simplify complex numerical computations; start by breaking down the problem into recognizable math patterns. Use Python’s built-in arithmetic and modules like `math` for functions such as `sqrt()`, `gcd()`, or `factorial()`. This helps in achieving optimal performance for computation-heavy problems.  - **Example:** Trailing Zeroes in Factorial.                                                                                           |
| **Miscellaneous: Specialized Data Structures**       | - When a custom data structure is needed to optimize specific queries. <br> - **Keywords:** "**`Trie`**", "**`LRU Cache`**", "**`data structure design`**".                             | - Implement using standard design patterns; for example, build a Trie using nested dictionaries or design an LRU Cache using a combination of a hash map and a doubly linked list. Start by outlining the key operations (insert, search, delete) and then map them to Python data structures like `dict` and `collections.OrderedDict` (or `functools.lru_cache` for caching).  - **Example:** Implement Trie.                                                                                                               |
