| **Category & Pattern**                                 | **When to Use**                                                                                                                                                                       | **Technique & Examples**                                                                                                                                                                                                                                                           |
|--------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Arrays & Strings: Sliding Window**                   | - Problems asking for the longest/shortest contiguous **`subarray`**/**`substring`** that meets a condition. <br> - **Keywords:** "**`subarray`**", "**`substring`**", "**`continuous`**", "**`maximize`**", "**`minimize`**". | - Use two pointers (start & end) to maintain a window. <br> - Adjust window size dynamically (expand/contract) based on condition. <br> - Track state with a counter or hash map. <br> **Examples:** Longest Substring Without Repeating Characters, Minimum Window Substring |
| **Arrays & Strings: Two Pointers**                     | - Sorted array problems (finding pairs, triplets, or partitions). <br> - Problems requiring comparison from both ends. <br> - **Keywords:** "**`sorted`**", "**`pair`**", "**`triplet`**", "**`partition`**".                                                                  | - Initialize pointers at both ends (or use one slow and one fast). <br> - Move pointers inward based on comparisons. <br> **Examples:** Two Sum II (sorted input), 3Sum, Reorder List                                                                                     |
| **Arrays & Strings: Prefix Sum & Hashing**             | - When the problem involves sums of subarrays or counting occurrences. <br> - **Keywords:** "**`subarray sum equals K`**", "**`group anagrams`**", "**`frequency`**".                                          | - Compute running totals (prefix sums). <br> - Use hash maps to store frequencies or complement lookups. <br> **Examples:** Subarray Sum Equals K, Group Anagrams                                                                                                          |
| **Graphs & Trees: Breadth-First Search (BFS)**         | - Finding the shortest path in an unweighted graph. <br> - Level order traversal of trees. <br> - **Keywords:** "**`minimum moves`**", "**`closest distance`**", "**`level order`**".                             | - Use a queue to process nodes level by level. <br> - Mark visited nodes to avoid cycles. <br> **Examples:** Binary Tree Level Order Traversal, Word Ladder                                                                                                                |
| **Graphs & Trees: Depth-First Search (DFS)**           | - Exploring all paths or checking for a specific condition. <br> - Problems that require backtracking or full tree traversal. <br> - **Keywords:** "**`all paths`**", "**`full traversal`**", "**`backtracking`**".                                                            | - Use recursion (or an explicit stack) to go deep before backtracking. <br> - Process nodes in pre-order, in-order, or post-order as needed. <br> **Examples:** Validate Binary Search Tree, Lowest Common Ancestor, Path Sum Problems                  |
| **Graphs & Trees: Union-Find (Disjoint Set)**          | - Problems with pairwise connections and grouping. <br> - When asked to detect cycles or count connected components. <br> - **Keywords:** "**`connected components`**", "**`cycle detection`**", "**`grouping`**".                                                                    | - Initialize each node as its own parent. <br> - Union connected nodes and use find with path compression. <br> **Examples:** Number of Islands, Redundant Connection                                                                                                          |
| **Graphs & Trees: Topological Sort**                   | - Ordering tasks with prerequisites. <br> - Problems involving dependency resolution. <br> - **Keywords:** "**`prerequisites`**", "**`dependency`**", "**`ordering`**", "**`course schedule`**".                                                                                                    | - **Kahn's Algorithm (BFS):** Use in-degrees and a queue. <br> - **DFS-Based:** Use post-order traversal with cycle detection. <br> **Examples:** Course Schedule, Alien Dictionary                                                                                             |
| **Backtracking & Recursion: Permutations & Combinations** | - Problems that require generating all possible arrangements. <br> - **Keywords:** "**`all permutations`**", "**`subsets`**", "**`combinations`**".                                                            | - Use recursion to build candidates one element at a time. <br> - Backtrack (undo choices) when a candidate fails a constraint. <br> **Examples:** Permutations, Subsets (Power Set), Letter Combinations of a Phone Number                                           |
| **Backtracking & Recursion: Constraint Satisfaction / Puzzle Solving** | - When you must find a configuration that meets strict constraints. <br> - **Keywords:** "**`solve`**", "**`arrangement`**", "**`configuration`**", "**`puzzle`**".                                                           | - Recursively try all options with pruning. <br> - Backtrack immediately when a constraint is violated. <br> **Examples:** N-Queens, Sudoku Solver, Remove Invalid Parentheses                                                                                       |
| **Backtracking & Recursion: Divide & Conquer (Recursive)** | - Problems that can be broken into similar subproblems. <br> - **Keywords:** "**`divide and conquer`**", "**`recursive`**", "**`merge sort`**", "**`quickselect`**".                                                                                                                                | - Define clear base cases. <br> - Combine solutions from divided subproblems. <br> **Examples:** Merge Sort, Quickselect for k-th largest element, Flatten Binary Tree to Linked List                                                                               |
| **Dynamic Programming (DP): 1D Sequence DP**           | - Problems on sequences where optimal decisions depend on previous elements. <br> - **Keywords:** "**`maximum`**", "**`minimum`**", "**`count`**", "**`ways`**", "**`optimal substructure`**".                                                    | - Define a DP array: `dp[i]` represents the solution up to index `i`. <br> - Formulate a recurrence based on decisions at each index. <br> **Examples:** House Robber, Climbing Stairs, Longest Increasing Subsequence                                                  |
| **Dynamic Programming (DP): 2D DP (Grids/Matrix)**     | - Problems with two parameters, like comparing two strings or navigating grids. <br> - **Keywords:** "**`2D`**", "**`matrix`**", "**`grid`**", "**`edit distance`**", "**`LCS`**".                                         | - Create a 2D table `dp[i][j]`. <br> - Fill the table iteratively (or use recursion with memoization) based on subproblem dependencies. <br> **Examples:** Longest Common Subsequence, Edit Distance, Unique Paths                                                                                                   |
| **Dynamic Programming (DP): State-Space DP (Bitmask, Tree DP)** | - Advanced problems with multiple state variables. <br> - **Keywords:** "**`choose subset`**", "**`bitmask`**", "**`state DP`**", "**`tree DP`**".                                                                       | - Define a state (e.g., using a bitmask for chosen elements). <br> - Use recursion and memoization to efficiently explore state space. <br> **Examples:** Traveling Salesman Problem (TSP), Scheduling with deadlines                                                                          |
| **Linked Lists: Fast & Slow Pointers**                 | - Detecting cycles or finding the middle of a list. <br> - **Keywords:** "**`cycle`**", "**`loop detection`**", "**`middle element`**", "**`Floyd's`**".                                                                                                                                     | - Use two pointers moving at different speeds (slow: 1 step, fast: 2 steps). <br> - If pointers meet, a cycle exists; use to locate the cycle start or middle element. <br> **Examples:** Linked List Cycle Detection (Floyd's Algorithm), Find Middle of Linked List                               |
| **Linked Lists: In-Place Reversal / Reordering**       | - Reversing an entire list or parts of it. <br> - **Keywords:** "**`reverse`**", "**`swap nodes`**", "**`reverse in groups`**".                                                                               | - Iterate through the list and update pointers. <br> - Use dummy nodes to simplify edge cases. <br> **Examples:** Reverse Linked List, Reverse Nodes in k-Group, Reorder List                                                                                       |
| **Linked Lists: Merging / Copying Lists**              | - Merging sorted linked lists or duplicating lists with extra pointers. <br> - **Keywords:** "**`merge`**", "**`copy`**", "**`duplicate`**", "**`random pointer`**".                                                                                                           | - Use two-pointer technique for merging sorted lists. <br> - For copying, use a hash map or interleave copied nodes. <br> **Examples:** Merge Two Sorted Lists, Merge k Sorted Lists (often with a heap), Copy List with Random Pointer                                      |
| **Searching, Sorting & Heaps: Binary Search**          | - Sorted arrays or “search space” problems. <br> - **Keywords:** "**`find`**", "**`first occurrence`**", "**`boundary`**", "**`optimal value`**", "**`sorted`**".                                                                    | - Iteratively (or recursively) split the search space. <br> - Define clear conditions for moving left/right. <br> **Examples:** Search in Rotated Sorted Array, First Bad Version, Find Peak Element                                                           |
| **Searching, Sorting & Heaps: Sorting & Intervals**    | - Problems involving intervals, overlapping ranges, or needing an ordered structure. <br> - **Keywords:** "**`intervals`**", "**`overlap`**", "**`merge`**", "**`sorted`**".                                                                                                   | - Sort by a key (e.g., start times) then process sequentially. <br> - Use greedy algorithms after sorting. <br> **Examples:** Merge Intervals, Meeting Rooms                                                                                                              |
| **Searching, Sorting & Heaps: Heaps / Priority Queues**| - Problems requiring retrieval of extreme elements (e.g., k-th largest, top-k) or processing streaming data. <br> - **Keywords:** "**`heap`**", "**`priority queue`**", "**`top k`**", "**`streaming`**".                                                           | - Use a min-heap or max-heap. <br> - For top-k, maintain a heap of fixed size. <br> **Examples:** Kth Largest Element in an Array, Top K Frequent Elements, Merge k Sorted Lists, Find Median from Data Stream                                                       |
| **Miscellaneous: Bit Manipulation**                    | - Problems involving bits or requiring low-level operations. <br> - **Keywords:** "**`bitwise`**", "**`XOR`**", "**`shift`**", "**`power of 2`**".                                                         | - Use bitwise operations (AND, OR, XOR, shifts) to manipulate bits. <br> - Common tricks: XOR to find unique element, n & (n-1) for power-of-2 check. <br> **Examples:** Single Number (using XOR), Reverse Bits, Check Power of Two                                                     |
| **Miscellaneous: Mathematical Puzzles**                | - Problems with strong mathematical components, often involving sequences or modular arithmetic. <br> - **Keywords:** "**`modulo`**", "**`fibonacci`**", "**`prime`**", "**`factorial`**", "**`formula`**".                                          | - Use known mathematical formulas or recurrence relations. <br> - Apply direct computation where possible. <br> **Examples:** Trailing Zeroes in Factorial, Happy Number, Excel Sheet Column Number                                                                                                          |
| **Miscellaneous: Specialized Data Structures**       | - When the problem requires a custom data structure implementation. <br> - **Keywords:** "**`Trie`**", "**`LRU Cache`**", "**`data structure design`**".                                                           | - Implement standard data structures using known patterns (Trie for prefix matching; LRU using a hash map and doubly linked list). <br> **Examples:** Implement Trie, Design LRU Cache, Add and Search Words Data Structure                                                              |